# 第5次工作记录

# 2022年4月25日- 2022年5月1日

# 学习内容和已完成设计（论文）内容

## 1. 学习使用Blaozr

因为js极其不擅长处理网络传输的字节流，且性能低下，webassemble 在这方面具有更高的性能。同时，js的动态类型和宽松的语法导致代码难以维护，编写程序时代码提示不够友好，大大降低了效率。微软推出的 Blazor 框架基于 webassemble ，在浏览器环境中构建出 .NET 运行环境，使得能够使用C#编写网页。但是，webassemble的生态比js差，所以Blazor提供了与js互操作的功能。

本周使用Blazor制作出了网页，并对数据绑定、路由等功能进行了探索。制作出的网页如图1.1所示

![image-20220501154308283](第5次工作记录.assets/image-20220501154308283.png)

<center>图1：本周制作的网页</center>



## 2. 编写了用于MQTT连接的Blazor组件

![image-20220501155307418](第5次工作记录.assets/image-20220501155307418.png)

该组件通过传入参数就可以轻松使用。该组件是通过razor语法对js的开源库mqtt.js进行的包装。同时实现该组件的独立性，降低耦合性，该组件通过被创建后往head标签添加script标签的方式导入mqtt.js，无需用户手动添加script标签。可以从CDN获取脚本，也可以手动将脚本放在本地的wwwroot文件夹中，使用 /js/mqtt.min.js 进行引用。

```javascript
/**
 * 从CDN获取mqtt.js并加载，加载完成后触发事件，调用 .NET 方法
 * @param {any} dotnetHelper
 */
export function installMqtt(dotnetHelper) {
    if (window.mqttInstalled === true) {
        dotnetHelper.invokeMethodAsync("OnInstalled");
    } else {
        let script = document.createElement('script');
        //script.src = "https://unpkg.com/mqtt/dist/mqtt.min.js";
        script.src = "/js/mqtt.min.js";
        script.async = true;
        script.onload = () => {
            dotnetHelper.invokeMethodAsync("OnInstalled");
        }
        document.head.append(script);
        window.mqttInstalled = true;
    }
}

```

## 3. 降低查找主题相应的处理函数的时间复杂度

MQTT消息采用主题加载荷的结构。主题是字符串的形式。当接收到一个消息后需要判断主题是什么，然后进入相应的处理函数。

ESP32的程序使用C++编写，C++的switch语句不支持字符串，但是map可以使用对象作为键或值。使用map就可以将查找的时间复杂度降低。避免使用大量的if-else语句对主题进行判断。

```c++
/**
 * @brief 收到订阅的主题的数据后被回调
 *
 * @param topic 主题。C风格的字符串
 *
 * @param payload 一个uint8_t数组的首地址。注意，如果内容是字符串，它的
 * 末尾并没有被添加空字符，需要手动添加
 *
 * @param length payload的长度
 */
void TestMQTTClient::OnReceive(char *topic, uint8_t *payload, unsigned int length)
{
    String topicStr = String(topic);
    StringSplitter subTopics(topicStr, '/', 10);
    int count = subTopics.getItemCount();
    if (count >= 3)
    {
        //至少要3级子主题
        int index = 0;
        if (subTopics.getItemAtIndex(index++) == "esp32")
        {
            if (subTopics.getItemAtIndex(index++) == "command")
            {
                auto it = m_commandMap.find(subTopics.getItemAtIndex(index++));
                if (it != m_commandMap.end())
                {
                    (it->second)(payload, length);
                }
            }
        }
    }
}

void TestMQTTClient::InitCommandMap(void)
{
    m_commandMap["msp"] = [](uint8_t *payload, uint32_t length) -> void
    {
        pTar->sendData(payload, length);
    };
}
```

在上面的代码中，一级和二级子主题因为数量较少，采用二级嵌套if-else语句进行解析，三级子主题量较大，使用if-else语句非常不合理，时间复杂度为O(n)，所以采用map，将时间复杂度降低为O(logn)

在构造函数中调用 InitCommandMap 函数往map中添加主题及对应的处理函数。其中，m_commandMap的类型为

```c++
    std::map<String, std::function<void(uint8_t *payload, unsigned int length)>> m_commandMap;
```

因为主题并不会在工作时插入，只会在初始化的时候插入，所以不会因为map内部对节点频繁进行排序而降低性能。

## 4. 绘制用户端业务的流程图

![image-20220501162251468](第5次工作记录.assets/image-20220501162251468.png)



# 本次工作中的收获

1. 学习了Blazor
2. 完成了通信功能的程序框架
3. 绘制了下一步工作的流程图
4. 降低了了主题查找的时间复杂度

# 与上周工作和原定进度安排相比，未完成的工作和原因

上周工作顺利完成

# 设计困难和解决方案，下周工作进度安排

1. 完成流程图中的程序
2. 完成论文到二级标题的初步构思

# 2022年5月2日- 2022年5月8日

# 学习内容和已完成设计（论文）内容



# 本次工作中的收获



# 与上周工作和原定进度安排相比，未完成的工作和原因



# 设计困难和解决方案，下周工作进度安排




# 第5次工作记录

# 2022年4月25日- 2022年5月1日

# 学习内容和已完成设计（论文）内容

## 1. 学习使用Blaozr

因为js极其不擅长处理网络传输的字节流，且性能低下，webassemble 在这方面具有更高的性能。同时，js的动态类型和宽松的语法导致代码难以维护，编写程序时代码提示不够友好，大大降低了效率。微软推出的 Blazor 框架基于 webassemble ，在浏览器环境中构建出 .NET 运行环境，使得能够使用C#编写网页。但是，webassemble的生态比js差，所以Blazor提供了与js互操作的功能。

本周使用Blazor制作出了网页，并对数据绑定、路由等功能进行了探索。制作出的网页如图1.1所示

![image-20220501154308283](第5次工作记录.assets/image-20220501154308283.png)

<center>图1：本周制作的网页</center>



## 2. 编写了用于MQTT连接的Blazor组件

![image-20220501155307418](第5次工作记录.assets/image-20220501155307418.png)

该组件通过传入参数就可以轻松使用。该组件是通过razor语法对js的开源库mqtt.js进行的包装。同时实现该组件的独立性，降低耦合性，该组件通过被创建后往head标签添加script标签的方式导入mqtt.js，无需用户手动添加script标签。可以从CDN获取脚本，也可以手动将脚本放在本地的wwwroot文件夹中，使用 /js/mqtt.min.js 进行引用。

```javascript
/**
 * 从CDN获取mqtt.js并加载，加载完成后触发事件，调用 .NET 方法
 * @param {any} dotnetHelper
 */
export function installMqtt(dotnetHelper) {
    if (window.mqttInstalled === true) {
        dotnetHelper.invokeMethodAsync("OnInstalled");
    } else {
        let script = document.createElement('script');
        //script.src = "https://unpkg.com/mqtt/dist/mqtt.min.js";
        script.src = "/js/mqtt.min.js";
        script.async = true;
        script.onload = () => {
            dotnetHelper.invokeMethodAsync("OnInstalled");
        }
        document.head.append(script);
        window.mqttInstalled = true;
    }
}

```

## 3. 降低查找主题相应的处理函数的时间复杂度

MQTT消息采用主题加载荷的结构。主题是字符串的形式。当接收到一个消息后需要判断主题是什么，然后进入相应的处理函数。

ESP32的程序使用C++编写，C++的switch语句不支持字符串，但是map可以使用对象作为键或值。使用map就可以将查找的时间复杂度降低。避免使用大量的if-else语句对主题进行判断。

```c++
/**
 * @brief 收到订阅的主题的数据后被回调
 *
 * @param topic 主题。C风格的字符串
 *
 * @param payload 一个uint8_t数组的首地址。注意，如果内容是字符串，它的
 * 末尾并没有被添加空字符，需要手动添加
 *
 * @param length payload的长度
 */
void TestMQTTClient::OnReceive(char *topic, uint8_t *payload, unsigned int length)
{
    String topicStr = String(topic);
    StringSplitter subTopics(topicStr, '/', 10);
    int count = subTopics.getItemCount();
    if (count >= 3)
    {
        //至少要3级子主题
        int index = 0;
        if (subTopics.getItemAtIndex(index++) == "esp32")
        {
            if (subTopics.getItemAtIndex(index++) == "command")
            {
                auto it = m_commandMap.find(subTopics.getItemAtIndex(index++));
                if (it != m_commandMap.end())
                {
                    (it->second)(payload, length);
                }
            }
        }
    }
}

void TestMQTTClient::InitCommandMap(void)
{
    m_commandMap["msp"] = [](uint8_t *payload, uint32_t length) -> void
    {
        pTar->sendData(payload, length);
    };
}
```

在上面的代码中，一级和二级子主题因为数量较少，采用二级嵌套if-else语句进行解析，三级子主题量较大，使用if-else语句非常不合理，时间复杂度为O(n)，所以采用map，将时间复杂度降低为O(logn)

在构造函数中调用 InitCommandMap 函数往map中添加主题及对应的处理函数。其中，m_commandMap的类型为

```c++
    std::map<String, std::function<void(uint8_t *payload, unsigned int length)>> m_commandMap;
```

因为主题并不会在工作时插入，只会在初始化的时候插入，所以不会因为map内部对节点频繁进行排序而降低性能。

## 4. 绘制用户端业务的流程图

![image-20220501162251468](第5次工作记录.assets/image-20220501162251468.png)



# 本次工作中的收获

1. 学习了Blazor
2. 完成了通信功能的程序框架
3. 绘制了下一步工作的流程图
4. 降低了了主题查找的时间复杂度

# 与上周工作和原定进度安排相比，未完成的工作和原因

上周工作顺利完成

# 设计困难和解决方案，下周工作进度安排

1. 完成流程图中的程序
2. 完成论文到二级标题的初步构思

# 2022年5月2日- 2022年5月8日

# 学习内容和已完成设计（论文）内容

## 1. 配置数据库

如下图所示，数据库中有两张表，一张用户表，一张设备表。用户表中有两个字段，一个字段是username，另一个字段是password。设备表有两个字段，一个字段是device_id，另一个字段是username，表示该设备属于哪个用户。

![image-20220501184116073](第5次工作记录.assets/image-20220501184116073.png)

## 2. 通过数据库进行用户认证

当一个 MQTT 客户端向 MQTT 服务器请求连接时，MQTT 服务器会向 HTTP 服务器发送 HTTP 报文，报文中携带了客户端的信息。HTTP 服务器查询数据库，在客户端信息正确时返回 200 状态码，若信息不正确，返回 200 以外的状态码。MQTT 服务器收到 HTTP 响应后检查状态码，如果是 200 则建立与 MQTT 客户端的连接，否则拒绝连接。

```c#
app.MapPost("/mqtt/auth", async (HttpContext context) =>
 {
     //MQTT客户端连接认证
     int length = 0;
     if (context.Request.ContentLength != null)
     {
         length = (int)context.Request.ContentLength;
     }
     byte[] body = new byte[length];
     await context.Request.Body.ReadAsync(body, 0, body.Length);
     string str = Encoding.UTF8.GetString(body);
     MqttAuthentication? au = JsonSerializer.Deserialize<MqttAuthentication>(str,new JsonSerializerOptions()
     {
         PropertyNameCaseInsensitive = true,//反序列化不区分大小写
     });
     if (au != null)
     {
         if(au.Username=="server" && au.IP=="127.0.0.1")
         {
             //HTTP服务器特殊认证通道
             context.Response.StatusCode = 200;
         }
         else
         {
             //其他客户端认证通道
             string selection = string.Format("SELECT * FROM [user] WHERE [username]='{0}';", au.Username);
             using(SqlDataReader reader = DataBase.GetReader(selection))
             {
                 if (reader.Read())
                 {
                     //找到该用户名
                     if (au.Password == reader["password"] as string)
                     {
                         //检查密码正确
                         context.Response.StatusCode = 200;
                         return;
                     }
                 }
             }
             context.Response.StatusCode = 404;
         }
     }
 });

```

HTTP 服务器本身也是一个 MQTT 客户端，它请求建立与 MQTT 服务器的连接的时候 MQTT 服务器也会发送 HTTP 请求给 HTTP 服务器要求验证。HTTP 服务器验证自己的方式和验证别的 MQTT 客户端的方式有所不同。HTTP 服务器在验证的时候首先检查用户名是不是 server ，如果是，再检查该客户端的 IP 地址，如果是本地的环回地址，则认证通过。server 用户没有密码，只能在本地环回地址使用。

## 3. 主题的规划

每个 MQTT 客户端订阅的主题的第一个子主题必须是自己的 MQTT 客户端 ID，这是为了让其它 MQTT 客户端能够找到该客户端。例如 server 订阅的主题为：server/# ，第一个子主题表示自己的客户端 ID，第二个子主题 # 是通配符，表示接收所有第一个子主题为 server 的主题的消息。

从第二个子主题开始就是和功能相关的。



# 本次工作中的收获



# 与上周工作和原定进度安排相比，未完成的工作和原因



# 设计困难和解决方案，下周工作进度安排



